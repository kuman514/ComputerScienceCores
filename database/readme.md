# 데이터베이스 모음집

## 데이터베이스란
- 전자적으로 저장되는 체계적인 데이터 모음집이다.
- 데이터에는 텍스트, 이미지, 영상, 음향, 파일 등등이 모든 유형을 포함한다.
- DBMS를 통해 데이터를 검색하거나 저장 또는 편집할 수 있다.

## DBMS (Database Management System)
- 데이터베이스를 관리해주는 소프트웨어이다.
- 데이터를 저장/열람/관리할 수 있게 만들어준다.

## 데이터베이스의 목적
- 데이터 보안
  - 데이터베이스 내 모든 데이터의 접근에 개인정보 보호 및 규정 준수 요구 사항을 지원한다.
  - 예: 데이터베이스에 접근하려면 사용자가 로그인을 해야 한다 등등
- 데이터 무결성 유지
  - 데이터베이스에는 데이터의 일관성을 보장하는 일정한 규칙이 마련되어 있다.
- 데이터 분석
  - 데이터베이스에 저장된 데이터를 기반으로 추세나 패턴을 식별하거나 예측을 실행할 수 있다.
  - 이러한 분석은 조직의 비즈니스 의사 결정에 큰 도움을 준다.
- 효율적인 확장
  - 데이터베이스는 수만/수억 건에 달하는 대량의 데이터를 관리할 수 있게 만들어준다.

## 트랜잭션
- 데이터베이스의 데이터를 변경하는 단위를 말한다.
- 완전성을 보장한다. 즉, 트랜잭션의 연산이 완전히 끝나지 못했다면 일부만 처리되지 않고 원래대로 돌아간다.
- 트랜잭션은 ACID하다는 특징을 가지고 있다.

### ACID
- 원자성 (Atomicity): 트랜잭션은 완전히 수행되거나 하나도 수행되어 있지 않아야 한다. ALL or NOTHING이라고 생각하자.
- 일관성 (Consistency): 트랜잭션의 처리 결과는 항상 일관적이어야 한다. 시스템이 가지고 있는 고정 요소는 실행되기 전과 후가 서로 같아야 한다. 즉, 데이터베이스의 규칙을 위반하는 트랜잭션은 수행할 수 없다.
- 고립성 (Isolation): 서로 다른 트랜잭션이 동시에 수행될 때, 서로의 연산에 끼어들 수 없다.
- 영구성 (Durability): 성공적으로 연산된 트랜잭션은 영구히 보존되어야 한다.

## 관계형 데이터베이스
- 데이터가 테이블(또는 릴레이션)으로 구조화된 데이터베이스.
### 1:1 관계
- 어떤 테이블의 한 데이터가 다른 테이블의 한 데이터에 대응되는 관계.
- 예: 사용자 테이블과 사용자의 전화번호 테이블의 관계
### 1:N 관계
- 어떤 테이블의 하나의 데이터가 다른 테이블의 여러 데이터에 대응되는 관계.
- 예: 사용자 테이블과 사용자가 전화번호부에 등록한 전화번호 테이블의 관계
### N:M 관계
- 어떤 테이블의 여러 데이터가 다른 테이블의 여러 데이터에 대응되는 관계.
- 두 테이블 사이에 중재하는 테이블을 두어 구현할 수 있다.
- 예: 고객 테이블과 상품 테이블의 관계 사이에 상품 주문 테이블을 만드는데, 이 때 상품 주문 테이블은 고객 테이블에 대해 1:N 관계 + 상품 테이블에 대해 1:N 관계를 맺는다
### 관계형 데이터베이스의 구성 요소
- 테이블 (Table) 또는 릴레이션 (Relation): 데이터베이스에서 데이터를 행과 열 형태의 구조로 모아 저장해놓은 공간.
- 스키마 (Schema) 또는 헤더 (Header): 데이터베이스 테이블과 데이터 구조의 정의, 즉 데이터베이스의 설계와 구조를 나타낸 것이다.
- 인스턴스 (Instance): 정의된 스키마를 따라 테이블 내 실제 값으로 저장된 데이터이다.
- 레코드 (Record) 또는 행(Row) 또는 튜플 (Tuple): 테이블 내 한 개의 데이터.
- 카디널리티 (Cardinality): 레코드의 개수.
- 속성 (Attribute) 또는 열 (Column) 또는 필드 (Field): 테이블 내 하나의 데이터 종류.
- 차수 (Degree): 속성의 개수.
- 도메인 (Domain): 속성이 가질 수 있는 값의 범위.
- 제약 조건 (Constraints): 데이터의 무결성을 보장하기 위한 제한 사항.
  - 예시: PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL 등등.
- 키 (Keys)
  - 슈퍼키 (Super Key): 테이블 내 중복되지 않는 (즉 유일한) 값을 가지는 속성.
  - 후보키 (Candidate Key): 슈퍼키 내 기본키들의 후보.
  - 기본키 (Primary Key): 후보키들 중 선정된 대표적인 키.
  - 대체키 (Alternative Key): 기본키가 아닌 후보키.
  - 외래키 (Foreign Key): 다른 테이블을 참조할 때 사용되는 키.

## 뷰 (View)
- 하나 이상의 테이블 또는 뷰를 기반으로 만들어진 가상 테이블.
- 실제 데이터로 저장되지 않으며, 기존 존재하는 테이블로부터 데이터를 추출하고 가공하여 사용자에게 새로운 테이블인 것처럼 보이게 한다.
- 장점
  - 원본 테이블이 변형되면 뷰의 내용도 자동으로 바뀌어진다.
  - 원본 테이블로부터 원하는 데이터를 필요한 형태로 가공하므로 권한을 제한해서 보여줄 수 있다.
  - 조인 또는 서브쿼리 등등의 복잡한 쿼리를 자동화하여 간단한 조회를 반복적으로 가능하게 해준다.
  - 실제 저장되는 원본 데이터로부터 독집적으로 존재하기 때문에, 원본 데이터를 훼손하지 않는다.
- 단점
  - 데이터 추가/수정/삭제 등의 갱신에 제약이 있다.
    - 뷰를 수정할 수 있게 만드는 조건
      - 단일 테이블 기반이어야 한다.
      - GROUP BY, JOIN, COUNT, DISTINCT 등의 연산이 없어야 한다.
      - SELECT 목록에 기본키를 포함해야 한다.
      - 뷰에서 정의되지 않은 속성은 Nullable이어야 한다.
  - 조인이 많을수록 성능이 저하될 수 있다.
  - 원본 테이블 구조가 변경되면, 뷰의 정의도 함께 수정해야 할 수 있다.

## 데이터베이스의 정규화
- 데이터베이스 내 데이터의 중복을 줄이고 데이터의 무결성을 보장하는 설계 방법이다.
- 정규화의 규칙은 제1/2/3정규화, BCNF 정규화, 제4/5정규화의 순서로 진행되며, 이는 "도부이결다조"로 요약될 수 있다.
### 제 1 정규화
- `도`메인이 원자값이어야 한다.
### 제 2 정규화
- 제 1 정규화를 만족한 상태에서, `부`분적 함수 종속을 제거함 (완전 함수 종속을 만족함).
### 제 3 정규화
- 제 2 정규화를 만족한 상태에서, `이`행적 함수 종속을 제거함.
- 이행적 종속이란, A->B, B->C가 성립할 때 A->C를 만족한다는 이야기이다.
- 기본키를 제외한 속성들 간 이행적 함수 종속이 없어야 한다.
### BCNF 정규화
- 제 3 정규화를 만족한 상태에서, 모든 `결`정자가 후보키 범위 내에 있어야 한다.
### 제 4 정규화
- BCNF 정규화를 만족한 상태에서, `다`치 종속을 제거함.
### 제 5 정규화
- 제 4 정규화를 만족한 상태에서, `조`인 종속을 제거함.

## 인덱스
- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 더욱 빠르게 만들어주는 자료구조.
  - 인덱스가 없다면, 테이블 검색 시 테이블 내의 모든 데이터를 탐색하는 Full Scan을 해야 한다.
- 인덱스의 장단점
  - 장점
    - 테이블을 조회하는 속도와 성능을 향상시킬 수 있다.
    - 전반적인 시스템의 부하가 줄어든다.
  - 단점
    - 인덱스를 관리하기 위해 (약 10퍼센트) 추가적인 공간이 필요하다.
    - 인덱스를 잘못 관리하면 성능이 오히려 저하된다.
    - 인덱스를 관리하기 위한 추가적인 작업이 필요하다.
- 인덱스 구현 예시
  - B-Tree
    - 이진 탐색 트리를 다중 분기 구조로 확장한 균형 트리 구조. 즉, 각 노드가 자식 노드를 2개 이상 가질 수 있는 균형 탐색 트리.
    - 루트 노드에서 리프 노드까지의 높이가 일정하게 유지되므로, 검색/삽입/삭제에 걸리는 시간복잡도가 모두 `O(logn)`이다.
    - 구조적 특징
      - 노드마다 2개 이상의 데이터(키(key)라고도 부름)가 들어가며, 노드 내에서 항상 정렬되어 저장된다.
      - `M`차 B-Tree(즉, 트리의 차수가 `M`인 B-Tree)의 각 노드는 `ceil(M / 2)` ~ `M`개의 자식 노드를 가질 수 있다.
      - `M`차 B-Tree의 각 노드는 `ceil(M / 2) - 1` ~ `M - 1`개의 데이터를 가질 수 있다.
      - 어떤 노드의 데이터가 `k`개라면, 그 노드의 자식 노드는 `k + 1`개여야 한다.
      - 어떤 노드 내 데이터보다 작은 데이터는 그 노드의 왼쪽 자식 노드에, 큰 데이터는 그 노드의 오른쪽 자식 노드에 저장된다.
      - 모든 리프 노드들은 서로 동일한 레벨에 존재한다.
    - 참고: https://code-lab1.tistory.com/217
  - B+Tree

## SQL
### 레코드 검색
- SELECT column_name, ...
  - DISTINCT
  - COUNT
  - *
  - AS alias
- FROM table_name
- JOIN
  - INNER JOIN right_table_name ON table_name.column_name = right_table_name.column_name
    - 왼쪽이나 오른쪽 두 곳 모두 데이터가 있으면 행을 출력
  - LEFT JOIN
    - 왼쪽에 데이터가 있으면 행을 출력
  - RIGHT JOIN
    - 오른쪽에 데이터가 있으면 행을 출력
  - OUTER JOIN
    - 왼쪽이나 오른쪽 중 한 쪽에 데이터가 있으면 행을 출력
- WHERE condition
  - AND / OR / NOT
- ORDER BY column_name
  - ASC / DESC
- GROUP BY column_name
  - HAVING

### 레코드 추가
- INSERT INTO table_name
- VALUES ( value, ... )

### 레코드 변경
- UPDATE table_name
- SET column = value, ...
- WHERE condition

### 레코드 삭제
- DELETE FROM table_name
- WHERE condition

### 테이블 생성
- CREATE TABLE table_name ( column_name data_type, ... );

### 뷰 생성
- CREATE VIEW view_name as SELECT ...;

### 테이블 변경
- ALTER TABLE table_name
  - ADD column_name data_type
  - DROP COLUMN column_name
  - RENAME COLUMN column_name TO new_column_name
  - MODIFY COLUMN column_name new_data_type

### 테이블 삭제
- DROP TABLE table_name;

### 뷰 삭제
- DROP VIEW view_name;
