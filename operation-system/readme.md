# 운영체제 모음집

## 프로세스와 스레드
- 프로세스
  - 프로세스란: 운영제체에서 실행 중인 프로그램. 운영체제에서 할당받은 작업의 단위.
  - 작동 방식
    - 운영체제로부터 메모리를 할당받아 독립된 공간에 데이터(Data), 코드(Code/Text), 힙(Heap), 스택(Stack) 영역을 구성한다.
      - 데이터(Data): 코드가 실행되면서 사용하는 전역 변수나 각종 데이터가 모인 영역.
      - 코드(Code/Text): 프로그래머들이 작성한 함수 등등이 기계어로 번역되어 저장된 영역.
      - 힙(Heap): 생성자나 인스턴스같은, 프로세스 내에서 동적으로 할당되는 데이터 위한 영역. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
      - 스택(Stack): 함수 내 지역변수같은, 함수 실행이 끝나면 상태가 되돌아올 임시적인 데이터를 위한 영역. 함수 호출과 함께 스택 영역이 할당되며, 함수 실행이 끝나면 해당 스택은 소멸된다. 만약 스택이 자기 메모리 영역을 초과하면, 스택 오버플로우가 발생한다.
  - 프로세스의 장점
    - 프로세스는 운영체제로부터 할당받은 독립된 메모리 공간 안에서 돌아가기 때문에, 다른 프로세스의 영역을 침범하지 못한다.
    - 프로세스들끼리의 동시성 문제는 운영체제의 스케줄링을 통해 자동으로 해결된다.
  - 프로세스의 단점
    - 프로세스들끼리 정보를 공유하려면 IPC(Inter-process Communication), LPC(Local Process Communication)을 사용하거나, 프로세스끼리 공유할 수 있는 별도의 공간을 만들어 두는 방법을 사용할 수 있다. 그러나 이럴 경우 자원 부담이 크기 때문에, 다중 작업이 필요한 경우 프로세스 여러 개를 실행하는 것보다, 하나의 프로세스 내에서 동시에 여러 개의 스레드를 실행하여 (즉, 멀티스레드를 통해) 처리하는 경우가 대부분이다.
- 스레드
  - 스레드란: 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위.
  - 스레드의 작동 방식
    - 프로세스가 할당받은 메모리 영역 내에서 스택 형식의 메모리 영역을 따로 할당받고, 데이터, 코드, 힙 형태의 메모리 영역은 스레드끼리 서로 공유한다.
      - 즉, 스레드는 자기만의 스택이 있고, 데이터, 코드, 힙 영역은 공유받는다.
  - 스레드의 장점
    - 다중 작업이 필요할 때, 자원 부담이 큰 멀티태스킹(프로세스를 여러 개 실행할 때)보다, 스레드를 여러 개 사용할 때 자원 부담이 적다.
    - 하나의 프로세스에서 여러 개의 스레드로 작업을 진행하면, 작업 수행 속도가 빨라진다.
  - 스레드의 단점
    - 스레드는 동일 프로세스의 메모리(데이터, 코드, 힙)을 공유받기 때문에, 하나의 스레드가 잘못되면 동일 프로세스 내 다른 모든 스레드도 잘못되어 프로세스가 강제종료될 위험이 있다.
    - 운영체제가 스레드를 스케줄링하지 않으므로, 프로그래머가 직접 프로세스 내의 스레드끼리의 동시성 문제를 해결해야 한다.
- 프로세스와 스레드의 차이점을 누군가가 묻는다면 해야할 대답?
  - 프로세스는 프로세스들끼리 공유하고 있는 파일을 손상시키지 않는 이상 하나의 프로세스가 종료돼도 다른 프로세스에 영향이 가진 않지만, 스레드는 하나가 잘못되면 프로세스 내 다른 모든 스레드가 악영향을 받게 된다.
- 출처
  - [인파님 블로그 - 완전히 정복하는 프로세스 vs 스레드 개념](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_process)
  - [개발장님 블로그 - 프로세스와 스레드의 차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)

## I/O
- 동기 I/O는 무엇인가?
  - 호출이 끝날 때까지 리턴되지 않는 유형의 I/O.
  - 프로세스는 I/O가 끝날 때까지 대기한다.
  - 코트 순차적으로 흐르기 때문에 코드 작성이 쉬운 장점이 있으나, CPU 자원이 놀 수 있다는 단점이 있다.
- 비동기 I/O는 무엇인가?
  - I/O 요청만 전달하고 바로 리턴되는 유형의 I/O.
  - 실제 I/O는 운영체제의 백그라운드에서 처리된다.
  - I/O 처리가 완료되는 시점에 운영체제가 신호나 콜백으로 알려준다.
  - 프로세스는 I/O를 기다리지 않고 다른 작업을 수행할 수 있다.
- 블로킹(Blocking) I/O는 무엇인가?
  - I/O 호출 시 완료될 때까지 프로세스가 멈추는 유형의 I/O. 결과가 준비되면 리턴된다.
  - 단순한 흐름이 장점이지만, I/O가 처리되는 기간이 길수록 비효율적인 단점이 있다.
- 논블로킹(Non-blocking) I/O는 무엇인가?
  - I/O 호출 시 즉시 리턴되는 유형의 I/O.
  - 데이터가 준비되지 않았다면 "데이터 없음" 상태를 리턴함.
  - 프로세스가 반복해서 재호출해야 한다. 즉, polling이 필요하다.
  - CPU 자원 낭비 가능성이 있는 대신, 다른 처리가 가능하다.
- 결론
  - 동기 I/O와 비동기 I/O의 차이는 완료 시점 기준, 즉 언제 결과를 받는가.
  - 블로킹 I/O와 논블로킹 I/O의 차이는 호출 시 프로세스가 멈추는가/바로 리턴되는가.
  - 사실 동기/비동기와 블로킹/논블로킹은 다른 기준이라 섞어서 보면 헷갈린다.
  - 예시
    - 블로킹 + 동기 (가장 흔함, read() 기본)
    - 논블로킹 + 동기 (소켓의 non-blocking mode)
    - 비동기 (POSIX aio_* 계열, Windows IOCP 같은 것)

## 이벤트 루프
