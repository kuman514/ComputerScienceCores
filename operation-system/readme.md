# 운영체제 모음집

## 프로세스와 스레드
- 프로세스
  - 프로세스란: 운영제체에서 실행 중인 프로그램. 운영체제에서 할당받은 작업의 단위.
  - 작동 방식
    - 운영체제로부터 메모리를 할당받아 독립된 공간에 데이터(Data), 코드(Code/Text), 힙(Heap), 스택(Stack) 영역을 구성한다.
      - 데이터(Data): 코드가 실행되면서 사용하는 전역 변수나 각종 데이터가 모인 영역.
      - 코드(Code/Text): 프로그래머들이 작성한 함수 등등이 기계어로 번역되어 저장된 영역.
      - 힙(Heap): 생성자나 인스턴스같은, 프로세스 내에서 동적으로 할당되는 데이터 위한 영역. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
      - 스택(Stack): 함수 내 지역변수같은, 함수 실행이 끝나면 상태가 되돌아올 임시적인 데이터를 위한 영역. 함수 호출과 함께 스택 영역이 할당되며, 함수 실행이 끝나면 해당 스택은 소멸된다. 만약 스택이 자기 메모리 영역을 초과하면, 스택 오버플로우가 발생한다.
  - 프로세스의 장점
    - 프로세스는 운영체제로부터 할당받은 독립된 메모리 공간 안에서 돌아가기 때문에, 다른 프로세스의 영역을 침범하지 못한다.
    - 프로세스들끼리의 동시성 문제는 운영체제의 스케줄링을 통해 자동으로 해결된다.
  - 프로세스의 단점
    - 프로세스들끼리 정보를 공유하려면 IPC(Inter-process Communication), LPC(Local Process Communication)을 사용하거나, 프로세스끼리 공유할 수 있는 별도의 공간을 만들어 두는 방법을 사용할 수 있다. 그러나 이럴 경우 자원 부담이 크기 때문에, 다중 작업이 필요한 경우 프로세스 여러 개를 실행하는 것보다, 하나의 프로세스 내에서 동시에 여러 개의 스레드를 실행하여 (즉, 멀티스레드를 통해) 처리하는 경우가 대부분이다.
- 스레드
  - 스레드란: 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위.
  - 스레드의 작동 방식
    - 프로세스가 할당받은 메모리 영역 내에서 스택 형식의 메모리 영역을 따로 할당받고, 데이터, 코드, 힙 형태의 메모리 영역은 스레드끼리 서로 공유한다.
      - 즉, 스레드는 자기만의 스택이 있고, 데이터, 코드, 힙 영역은 공유받는다.
  - 스레드의 장점
    - 다중 작업이 필요할 때, 자원 부담이 큰 멀티태스킹(프로세스를 여러 개 실행할 때)보다, 스레드를 여러 개 사용할 때 자원 부담이 적다.
    - 하나의 프로세스에서 여러 개의 스레드로 작업을 진행하면, 작업 수행 속도가 빨라진다.
  - 스레드의 단점
    - 스레드는 동일 프로세스의 메모리(데이터, 코드, 힙)을 공유받기 때문에, 하나의 스레드가 잘못되면 동일 프로세스 내 다른 모든 스레드도 잘못되어 프로세스가 강제종료될 위험이 있다.
    - 운영체제가 스레드를 스케줄링하지 않으므로, 프로그래머가 직접 프로세스 내의 스레드끼리의 동시성 문제를 해결해야 한다.
- 프로세스와 스레드의 차이점을 누군가가 묻는다면 해야할 대답?
  - 프로세스는 프로세스들끼리 공유하고 있는 파일을 손상시키지 않는 이상 하나의 프로세스가 종료돼도 다른 프로세스에 영향이 가진 않지만, 스레드는 하나가 잘못되면 프로세스 내 다른 모든 스레드가 악영향을 받게 된다.
- 출처
  - [인파님 블로그 - 완전히 정복하는 프로세스 vs 스레드 개념](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_process)
  - [개발장님 블로그 - 프로세스와 스레드의 차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)

## I/O
- 동기 I/O는 무엇인가?
  - 호출이 끝날 때까지 리턴되지 않는 유형의 I/O.
  - 프로세스는 I/O가 끝날 때까지 대기한다.
  - 코트 순차적으로 흐르기 때문에 코드 작성이 쉬운 장점이 있으나, CPU 자원이 놀 수 있다는 단점이 있다.
- 비동기 I/O는 무엇인가?
  - I/O 요청만 전달하고 바로 리턴되는 유형의 I/O.
  - 실제 I/O는 운영체제의 백그라운드에서 처리된다.
  - I/O 처리가 완료되는 시점에 운영체제가 신호나 콜백으로 알려준다.
  - 프로세스는 I/O를 기다리지 않고 다른 작업을 수행할 수 있다.
- 블로킹(Blocking) I/O는 무엇인가?
  - I/O 호출 시 완료될 때까지 프로세스가 멈추는 유형의 I/O. 결과가 준비되면 리턴된다.
  - 단순한 흐름이 장점이지만, I/O가 처리되는 기간이 길수록 비효율적인 단점이 있다.
- 논블로킹(Non-blocking) I/O는 무엇인가?
  - I/O 호출 시 즉시 리턴되는 유형의 I/O.
  - 데이터가 준비되지 않았다면 "데이터 없음" 상태를 리턴함.
  - 프로세스가 반복해서 재호출해야 한다. 즉, polling이 필요하다.
  - CPU 자원 낭비 가능성이 있는 대신, 다른 처리가 가능하다.
- 결론
  - 동기 I/O와 비동기 I/O의 차이는 완료 시점 기준, 즉 언제 결과를 받는가.
  - 블로킹 I/O와 논블로킹 I/O의 차이는 호출 시 프로세스가 멈추는가/바로 리턴되는가.
  - 사실 동기/비동기와 블로킹/논블로킹은 다른 기준이라 섞어서 보면 헷갈린다.
  - 예시
    - 블로킹 + 동기 (가장 흔함, read() 기본)
    - 논블로킹 + 동기 (소켓의 non-blocking mode)
    - 비동기 (POSIX aio_* 계열, Windows IOCP 같은 것)

## 스케줄링
- 스케줄링의 목적
  - CPU라는 비싼 자원을 효율적으로 쓰기 위해 프로세스에게 실행 순서를 부여해준다.
- 스케줄링의 유형
  - 비선점형
    - 프로세스가 CPU를 자진 반납할 때까지 뺏어올 수 없는 스케줄링 유형.
    - 강제 종료가 되지 않는다.
    - 문맥 교환으로 인한 오버헤드가 적은 편.
    - 응답성이 낮을 수도 있음.
  - 선점형
    - 중간에 프로세스로부터 CPU를 뺏어와 다른 프로세스에 부여할 수 있는 스케줄링 유형.
    - 긴급한 작업을 우선 처리할 수 있다.
    - 빠른 응답 시간을 보장한다.
    - Windows나 MacOS 등등 현대의 대부분 운영체제에서 사용되고 있다.
- 대표적인 스케줄링 방식
  - FIFO (First In First Out)
    - 먼저 온 순서대로 프로세스에게 CPU를 부여하는 스케줄링 방식.
    - 단순하고 공평해 보이지만, 실행 시간이 긴 프로세스가 CPU를 부여받을 경우 그 뒤 프로세스들이 하염없이 기다려야 한다. (즉 호위 효과 발생)
  - SJF (Shortest Job First)
    - 실행 시간이 가장 짧은 프로세스에게 우선 CPU를 부여하는 스케줄링 방식.
    - 평균 대기 시간을 가장 크게 줄일 수 있는 효율적인 방식이지만, 실행 시간이 짧은 프로세스가 계속 들어올 경우 실행 시간이 긴 프로세스가 영원히 CPU를 부여받지 못할 수도 있다. (즉 기아 현상 발생)
  - 라운드 로빈 (Round Robin)
    - 모든 프로세스가 동일한 시간만큼 CPU를 쓰고 시간이 다 된 프로세스는 다시 맨 뒤로 돌아가 대기하는 스케줄링 방식. 현대 시분할(Time-sharing) 시스템의 기초가 된다.
    - 어떤 프로세스도 하염없이 기다리지 않음을 보장하고, 응답성이 좋다.
    - 주의사항으로, 한 프로세스에 CPU를 너무 오래 부여할 경우 FIFO와 다를 바가 없어지고, 너무 짧게 부여할 경우 문맥 교환으로 인한 오버헤드가 커진다는 점이 있다.
  - 우선순위 스케줄링 (Priority Scheduling)
    - 우선순위가 높은 프로세스를 먼저 실행하는 스케줄링 방식.
    - 우선순위가 낮아 실행되지 못하고 있는 프로세스의 기아 현상을 방지하기 위해, 오래 기다릴 경우 우선순위를 부여해주는 에이징 기법을 사용할 수 있다.
- 문맥 교환 (Context Switching)
  - CPU가 현재 실행 중인 프로세스의 상태를 저장하고, 다음 프로세스에 CPU를 부여하기 위한 과정.
  - 이 과정 자체에서도 자원을 소모하므로, 너무 잦을 경우 성능 저하가 발생할 수 있다.
