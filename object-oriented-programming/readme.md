# 객체지향 프로그래밍 모음집

## 절차지향 프로그래밍
- 코드의 흐름으로 소프트웨어의 로직을 작성하는 프로그래밍 패러다임.
- 대표적인 예시로, C가 있다.

## 객체지향 프로그래밍
- 생활 속 사물을 표현한 객체 단위로 소프트웨어의 로직을 작성하는 프로그래밍 패러다임.
- 대표적인 구현의 예시로, Java와 C++의 클래스가 있다.

## 객체지향 프로그래밍의 특징
- 캡슐화: 데이터와 이를 조작하는 메소드를 하나의 단위로 묶고, 외부로는 필요한 부분만 공개함으로써 데이터의 무결성을 보장한다.
- 상속: 자식 클래스는 부모 클래스의 모든 특징을 이어받는다.
- 다형성: 하나의 객체는 다른 여러 형태로 재구성될 수 있다. (오버로딩, 오버라이딩 등을 통해)
- 추상화: 추상 클래스나 인터페이스 등등을 통해, 복잡한 사물 등등으로부터 필요한 핵심 특징만 모델링하여 단순화한다.

## 객체지향 프로그래밍의 장단점
- 장점
  - 재사용성을 지닌다.
  - 생산성을 향상시킨다.
  - 자연적인 모델링이 가능하다.
  - 유지보수에 용이하다.
- 단점
  - 초기 설계에 시간이 많이 들고 복잡하다.
  - 과도한 객체 분리로 성능이 저하될 우려가 있다.
  - 절차지향보다 메모리 사용량이 많다.

## 클래스와 객체
- 클래스(Class): 객체를 생성하기 위한 설계도 또는 틀. 속성과 메서드를 정의한다.
- 객체(Object): 클래스로부터 생성된 실체(Instance)로, 실제 메모리에 존재한다.
- 인스턴스화(Instantiation): 클래스로부터 객체를 생성하는 과정.

## 객체 간 상호작용
- 객체들은 서로 독립적으로 존재하며, 메시지를 주고받으며 협력한다.
- 한 객체는 다른 객체의 메서드를 호출(메시지 전달)하여 작업을 요청한다.

## 클래스를 이루는 요소
- 생성자, 파괴자
- 속성: 클래스의 데이터.
- 메소드: 클래스의 기능.
- 클래스의 상속
  - 오버로딩: 동일한 이름의 메소드에 파라미터를 달리 하여 재정의함으로써 다양한 유형의 호출에 대한 로직을 구현. 리턴 타입은 상관 없음.
  - 오버라이딩: 부모 클래스로부터 상속받은 메소드 중 동일한 이름과 파라미터 그리고 리턴 타입의 메소드에 자식 클래스에서의 로직을 달리하여 재정의.
- 클래스의 접근자
  - public: 클래스 외부라면 얼마든지 접근할 수 있음.
  - protected: 직접적인 상속 관계(부모와 자식 관계)에 한하여 접근할 수 있음.
  - private: 클래스 내부에서만 접근할 수 있음. 외부는 일체 접근 물가.

## 클래스 간 관계
- is-a 관계: 상속 관계 (예: Dog is a Animal)
- has-a 관계: 포함 관계 (예: Car has a Engine)

## SOLID

### Single Responsibility Principle (단일 책임 원칙)
- 소프트웨어 모듈은 변화를 일으키는 이유가 단 한 가지뿐이어야 한다.
- 모든 클래스는 단 하나의 책임만을 가지며, 그 책임을 모두 캡슐화해야 한다.
- 하나의 클래스에서 두 가지 이상의 책임을 가지면, 결합도가 높아져 유지보수가 어렵게 된다.

### Open/Closed Principle (개방-폐쇄 원칙)
- 확장에는 개방적이고 변경에는 폐쇄적이어야 한다.
- 확장에 개방적이라는게 무슨 의미?
  - 클래스를 상속(extends class)하거나 인터페이스를 구현(implements interface)함으로써 기능을 추가하는 것.
- 변경에 폐쇄적이라는게 무슨 의미?
  - 클래스 자체를 직접적으로 바꾸는 것을 지양하고 상속과 구현을 통해 기능을 추가하라는 것.

### Liskov Substitution Principle (리스코프 치환 원칙)
- 자식 클래스는 부모 클래스인 것 마냥 완전히 똑같이 다루어져야 한다.
- 자식 클래스는 부모 클래스의 행동을 파괴해선 안 된다.
- 예: Sparrow 클래스와 Ostrich 클래스가 Bird 클래스를 상속하고자 한다.
  - 이 때, Bird 클래스에 하늘을 난다는 fly 메소드가 있을 때, 날 수 없는 타조인 Ostrich 클래스가 이를 상속받으려면 fly 메소드를 파괴해야 한다.
  - 해결 방안으로, Bird 클래스 대신 이를 상속받는 FlyingBird 클래스에 fly 메소드를 부여하고, Ostrich 클래스는 Bird 클래스를, Sparrow 클래스는 FlyingBird 클래스를 상속받는다.

### Interface Segregation Principle (인터페이스 분리 원칙)
- 사용자들은 사용하지 않는 인터페이스를 강요받아선 안 된다.
- 예: Mechanic 클래스는 Car 클래스에 대해 repair 메소드를 제공받을 것인데, 이 때 Mechanic 클래스에 불필요한 sell같은 메소드가 Car 클래스에 있으면 안 된다.
  - 해결 방안으로, Car 클래스를 repair 메소드만 있는 Repairable 인터페이스와 sell 메소드만 있는 Sellable 인터페이스로 나누고, Mechanic 클래스에는 Repairable 인터페이스만 제공될 수 있도록 한다.
  - Repairable 인터페이스: repair(...) 메소드
  - Sellable 인터페이스: sell(...) 메소드
  - Car 클래스 implements Repairable, Sellable
  - Mechanic 클래스: repair(repairable: Repairable) { repairable.repair(...); }

### Dependency Inversion Principle (의존 역전 원칙)
- 고수준 모듈은 저수준 모듈에 의존하지 말아야 하고, 둘 다 추상 모듈에 의존해야 한다.
- 추상 모듈은 세부 모듈에 의존하지 말아야 하고, 세부 모듈은 추상 모듈에 의존해야 한다.
