# 알고리즘 모음집

## 정렬
- 버블 정렬
  - n번째서부터 시작하여 1번째 원소에 다다르기까지 서로 인접한 원소를 비교하는 정렬 방법.
  - 1~n번째 범위에서 시작하여, 1~(n-1)번째, 1~(n-2)번째, ..., 1~2번째 범위가 될 때까지 과정을 반복한다.
  - `O(n**2)`의 시간복잡도를 가진다.
- 선택 정렬
  - 정해진 위치에 들어갈 원소를 찾아 꽂는 정렬 방법.
  - 1번째 원소의 자리에는 가장 작은 원소를, 2번째 원소의 자리에는 2번째로 작은 원소를, ..., 마지막 원소의 자리에는 가장 큰 원소를 선택하여 꽂는다.
  - `O(n**2)`의 시간복잡도를 가진다.
- 삽입 정렬
  - 선택된 원소가 정렬된 부분의 몇 번째로 들어갈지 찾아 꽂는 정렬 방법.
  - n번째 원소가 선택되었을 때, 정렬된 부분의 원소들과 비교하여 몇 번째로 작은지 탐색하여 그 위치로 들어간다.
  - `O(n**2)`의 시간복잡도를 가진다.
- 병합 정렬
  - 하나의 리스트를 두 개의 균등한 크기의 부분 리스트로 분할하여, 분할된 부분 리스트부터 정렬하는 것으로 시작하여, 두 개의 정렬된 부분 리스트를 합하여 최종적으로 정렬된 전체 리스트로 병합시키는 정렬 방법.
  - `O(n*logn)`의 시간복잡도를 가진다.
  - 분할된 부분 리스트에 대한 추가적인 메모리가 요구된다.
- 힙 정렬
  - 힙 트리를 이용하여 가장 작은/큰 원소를 하나하나 빼내는 정렬 방법.
  - `O(n*logn)`의 시간복잡도를 가진다.
- 퀵 정렬
  - 리스트 안의 하나의 원소를 피벗으로 삼아, 피벗보다 작을 경우 왼쪽 부분 리스트로, 클 경우 오른쪽 부분 리스트로 원소를 이동시켜, 부분 리스트에서도 동일한 방법을 수행하는 정렬 방법.
  - `O(n*logn)`의 시간복잡도를 가지지만, 최악의 경우 `O(n**2)`의 시간복잡도를 가진다.

## 탐색
- BFS(너비 우선 탐색)
  - 그래프의 시작 정점으로부터 인접한 모든 정점들을 우선 방문하는 탐색법이다.
  - 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 정점에 대해서도 너비 우선 탐색을 적용한다.
  - 큐를 활용하여 다음에 방문할 정점을 결정한다.
- DFS(깊이 우선 탐색)
  - 그래프의 시작 정점으로부터 인접한 하나의 정점을 우선적으로 최대한 깊이 탐색하는 탐색법이다.
  - 하나의 경로를 최대한 가다가 길이 막히면 다른 갈림길을 탐색한다.
- 이분 탐색
  - 오름차순 또는 내림차순으로 정렬된 배열에서, 답을 찾을 때까지 전체 범위에서부터 시작하여 가운데에 위치한 값을 기준으로 범위를 절반씩 좁혀나가는 탐색 방법.
  - 현재 단계의 범위에서 가장 왼쪽의 원소를 left번째 원소, 가장 오른쪽에 있는 원소를 right번째 원소라고 할 때, 찾고자 하는 값이 가운데에 위치한 값보다...
    - 작으면, 다음 단계의 범위의 right가 현재 단계의 가운데 바로 왼쪽으로 오게 되고,
    - 크면, 다음 단계의 범위의 left가 현재 단계의 가운데 바로 오른쪽으로 오게 된다.

## 분할 정복
- 하나의 거대한 문제를 작은 문제들로 분리하여 그 작은 문제들부터 시작하여 최종적으로 하나의 거대한 문제까지 해결해나가는 방법.

## 동적 계획법 (다이나믹 프로그래밍)
- 하나의 거대한 문제를 작은 문제들로 분리하여 그 작은 문제들부터 시작하여 최종적으로 하나의 거대한 문제까지 해결해나간다는 점에서 분할 정복과 비슷하다.
- 동적 계획법은 나눈 문제를 한 번만 해결하고 이전에 해결했던 문제의 결과값이 필요할 때 재계산하지 않고 바로 다시 불러올 수 있게끔 메모이제이션을 활용한다.
- 가장 대표적인 예시로, 재귀 함수가 아닌 메모 배열을 이용하여 피보나치 수열 구하기 문제가 있다.

## 백트래킹
- 모든 경우의 수를 찾되, 현재의 풀이에서 더 이상 유효하지 않다(해가 없다)고 판단될 때 이전 풀이로 되돌아가는 방식의 문제 해결 방법이다.
- 가지치기 (pruning): 백트래킹에서 더 이상 유효하지 않아 탐색하는 의미가 없는 부분을 제외하는 행위.
