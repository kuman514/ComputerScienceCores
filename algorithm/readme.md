# 알고리즘 모음집

## 알고리즘의 효율성 판단 기준
- 시간 복잡도
  - 알고리즘을 수행하는데 얼마나 많은 시간을 소요하는가?
  - 예시로, 병합 정렬은 정렬에 `O(n*logn)` 정도의 시간이 걸리지만, 버블 정렬은 `O(n**2)` 정도의 시간이 걸린다.
- 공간 복잡도
  - 알고리즘을 수행하기 위해 얼마나 더 많은 메모리를 사용해야 하는가?
  - 예시로, 병합 정렬은 `O(n)`의 추가 메모리를 필요로 하지만, 퀵 정렬은 `O(logn)` 정도면 충분하다.
- 제자리 (In-place)
  - 추가 메모리를 요구하지 않고 원본 배열에서 변환하는가?
  - 배열 등등의 공간을 추적하는데 필요한 포인터로 인해 (재귀 함수 호출 등등) 추가 공간을 요구할 수도 있다.
    - 예시로, 버블 정렬은 몇 가지 포인터만 필요하므로 `O(logn)`의 추가 공간이 요구되지만, 퀵 정렬의 분할 정복 전략에서 하위 배열을 추적하기 위해 `O((log**2)n)`의 추가 공간이 요구된다.
- <정렬> 안정성 (Stable)
  - 기준에서 동일한 값을 가진 엘리먼트들의 순서가 정렬 후에도 유지되는가?
  - 예시로, 병합 정렬은 동일한 값을 가진 엘리먼트들이 정렬 후에도 순서를 유지하지만, 퀵 정렬은 그렇지 않다.

## 정렬
- 버블 정렬
  - n번째서부터 시작하여 1번째 원소에 다다르기까지 서로 인접한 원소를 비교하는 정렬 방법.
  - 1~n번째 범위에서 시작하여, 1~(n-1)번째, 1~(n-2)번째, ..., 1~2번째 범위가 될 때까지 과정을 반복한다.
  - `O(n**2)`의 시간복잡도를 가진다.
  - 안정성이 있는 정렬 방법이다.
  - 제자리 정렬 방법이다.
- 선택 정렬
  - 정해진 위치에 들어갈 원소를 찾아 꽂는 정렬 방법.
  - 1번째 원소의 자리에는 가장 작은 원소를, 2번째 원소의 자리에는 2번째로 작은 원소를, ..., 마지막 원소의 자리에는 가장 큰 원소를 선택하여 꽂는다.
  - `O(n**2)`의 시간복잡도를 가진다.
  - 불안정한 정렬 방법이다.
  - 제자리 정렬 방법이다.
- 삽입 정렬
  - 선택된 원소가 정렬된 부분의 몇 번째로 들어갈지 찾아 꽂는 정렬 방법.
  - n번째 원소가 선택되었을 때, 정렬된 부분의 원소들과 비교하여 몇 번째로 작은지 탐색하여 그 위치로 들어간다.
  - `O(n**2)`의 시간복잡도를 가진다.
  - 안정성이 있는 정렬 방법이다.
  - 제자리 정렬 방법이다.
- 병합 정렬
  - 하나의 리스트를 두 개의 균등한 크기의 부분 리스트로 분할하여, 분할된 부분 리스트부터 정렬하는 것으로 시작하여, 두 개의 정렬된 부분 리스트를 합하여 최종적으로 정렬된 전체 리스트로 병합시키는 정렬 방법.
  - `O(n*logn)`의 시간복잡도를 가진다.
  - 안정성이 있는 정렬 방법이다.
  - 분할된 부분 리스트에 대한 추가적인 메모리가 요구된다. `O(n)`의 공간 복잡도를 가진다.
- 힙 정렬
  - 힙 트리를 이용하여 가장 작은/큰 원소를 하나하나 빼내는 정렬 방법.
  - `O(n*logn)`의 시간복잡도를 가진다.
  - 불안정한 정렬 방법이다.
  - 제자리 정렬 방법이다.
- 퀵 정렬
  - 리스트 안의 하나의 원소를 피벗으로 삼아, 피벗보다 작을 경우 왼쪽 부분 리스트로, 클 경우 오른쪽 부분 리스트로 원소를 이동시켜, 부분 리스트에서도 동일한 방법을 수행하는 정렬 방법.
  - `O(n*logn)`의 시간복잡도를 가지지만, 최악의 경우 (즉, 피벗이 계속 최소값이나 최대값으로만 잡히는 경우) `O(n**2)`의 시간복잡도를 가진다.
    - 최악의 경우를 피하기 위해 사용하는 기법
      - 피벗 랜덤으로 고르기 (Randomized Pivot) 기법.
      - 배열 내 맨 앞, 중간, 맨 뒤의 세가지 값을 우선 정렬하여 그 중 중간값을 피벗으로 삼는 Median-of-three 기법.
  - 불안정한 정렬 방법이다.
  - 제자리 정렬 방법이다.
- 팀 정렬 (Timsort)
  - Java, Python, JavaScript 등 현대 프로그래밍 언어의 표준 라이브러리에서 사용되는 정렬 방법.
  - 삽입 정렬과 병합 정렬의 하이브리드 유형이다.
  - 작동 과정
    - 배열을 분할한다.
      - 일반적으로 분할된 배열은 `2**5(=32) ~ 2**6(=64)`개의 원소를 가진다.
      - 이렇게 나뉘어진 분할을 런(Run)이라고 부른다.
    - 각 런을 삽입 정렬로 정렬시킨다.
    - 병합된 런을 병합 정렬로 병합시킨다.
  - 왜 런 정렬에 `O(n**2)`가 걸리는 삽입 정렬을 쓴 거지?
    - 삽입 정렬은 인접한 원소끼리 비교하기 때문에, 참조 지역성의 원리를 잘 준수한다.
      - 참조 지역성의 원리란, CPU가 미래에 원하는 데이터를 예측하여, 속도가 빠른 장치인 캐시에 메모리를 담아놓는데, 이 때의 예측률을 높이기 위해 사용되는 원리이다.
        - 즉, 최근에 참조한 메모리와 그와 인접한 메모리를 다시 참조할 확률이 높다는 이론에 근거하여 캐시에 담아놓는 것.
      - 알고리즘의 시간 복잡도 `O(n*logn)`의 실제 동작 시간은 `O(C*n*logn+a)`이다.
        - 여기서 `C`는, 참조 지역성의 원리를 많이 준수할수록 그 값이 낮아진다.
      - 삽입 정렬과 병합 정렬의 `C`값 차이
        - 삽입 정렬은 인접한 원소끼리 비교하므로 참조 지역성의 원리를 잘 준수하기 때문에 `C`값이 낮지만,
        - 병합 정렬은 그렇지 못하기 때문에 (인접한 원소끼리 비교하는 빈도가 낮음) `C`값이 높다.
      - 결론,
        - 삽입 정렬의 `C`값을 `Ci`라고 하고, 병합 정렬의 `C`값을 `Cm`이라고 할 때 `Ci < Cm`이기 때문에,
        - 삽입 정렬의 실제 동작 시간 `O(Ci*(n**2)+a)`이 병합 정렬의 실제 동작 시간 `O(Cm*n*logn+a)`보다 짧은 `n`이 있다는 점이다.
      - 출처: https://d2.naver.com/helloworld/0315536
    - 즉, 요약하자면 작은 `n`(즉 원소의 개수가 작은 배열)에 대해서는, 삽입 정렬이 더 빠르다.

## 탐색
- 가중치가 없는 그래프 탐색
  - BFS(너비 우선 탐색)
    - 그래프의 시작 정점으로부터 인접한 모든 정점들을 우선 방문하는 탐색법이다.
    - 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 정점에 대해서도 너비 우선 탐색을 적용한다.
    - 큐를 활용하여 다음에 방문할 정점을 결정한다.
  - DFS(깊이 우선 탐색)
    - 그래프의 시작 정점으로부터 인접한 하나의 정점을 우선적으로 최대한 깊이 탐색하는 탐색법이다.
    - 하나의 경로를 최대한 가다가 길이 막히면 다른 갈림길을 탐색한다.
    - 스택 또는 재귀함수로 다음에 방문할 정점을 결정한다.
- 가중치가 있는 그래프 탐색
  - 데이크스트라 알고리즘
    - 가중치 그래프에서, 하나의 정점으로부터 나머지 모든 정점으로 가는 최소 비용을 계산하는 알고리즘.
    - 가중치가 음수가 아닌 경우에만 가능.
    - 동작 방식
      - 시작 정점으로의 비용은 0으로, 그 외 다른 정점으로의 비용은 무한대로 초기화.
      - 현재까지의 최소 비용이 가장 낮은 정점을 선택하고, 그 선택된 정점에 대해 인접한 정점까지의 가중치를 합하여 최소 비용을 갱신한다.
        - 모든 정점으로의 비용에 대한 계산이 완료될 때까지 반복.
    - 시간 복잡도: 정점을 선택하는데 있어 우선순위 큐를 사용할 경우 `O(e*logv)`
    - 사용 예시: GPS, 네비게이션, 네트워크 라우팅 등등.
  - 벨만-포드 알고리즘
    - 가중치 그래프에서, 하나의 정점으로부터 나머지 모든 정점으로 가는 최소 비용을 계산하는 알고리즘.
    - 데이크스트라 알고리즘과 달리, 가중치가 음수일 경우에도 가능.
    - 음수 사이클을 탐지할 수 있다.
    - 동작 방식
      - 시작 정점으로의 비용은 0으로, 그 외 다른 정점으로의 비용은 무한대로 초기화.
      - 모든 간선을 하나씩 확인하여, 각 간선을 통해 다른 정점으로 가는 비용을 계산하여 최소 비용을 갱신한다.
        - 이 과정을 (정점의 개수 - 1)번 반복한다.
      - 이 때, 위의 과정을 한 번 더 수행하여 (즉 정점의 개수번째 반복에서) 비용 테이블이 또 다시 갱신된다면, 이는 음수 사이클이 존재한다는 의미이다.
    - 시간 복잡도: `O(e*v)`
    - 사용 예시: 분산 시스템의 네트워크 신뢰성 분석 등등.
      - 에너지 망이나 통신망처럼 링크의 상태가 수시로 변하고 심지어 가중치가 음수가 될 수 있는 복잡한 시스템에서 경로를 계산할 때 사용.
  - 최소 비용 신장 트리
    - 신장 트리란
      - 그래프의 모든 정점을 연결한 간선들의 집합. 즉, 모든 정점에 대한 최소한의 연결만을 남긴 그래프이다.
      - 트리이므로 사이클이 발생하지 않아야 한다.
      - 하나의 정점에서 다른 인접한 정점으로의 간선이 두 개 이상일 경우, 하나의 간선만 채택한다.
    - 최소 비용 신장 트리란
      - 신장 트리 중 비용이 가장 낮도록 구성된 트리.
    - 유형
      - 크루스칼 알고리즘
        - 최소 신장 비용 트리를 찾는 알고리즘 중 하나. 정점을 연결한 모든 간선을 가중치 기준으로 정렬하여 최소 신장 트리를 만들어낸다.
        - 가중치가 음수여도 가능.
        - 동작 방식
          - 모든 간선을 가중치 오름차순으로 정렬.
          - 가중치가 가장 낮은 간선부터 확인하여, 두 정점이 연결되어 있지 않다면 해당 간선을 선택한다.
            - 이 때, 사이클 생성을 방지하기 위해 유니온 파인드 알고리즘을 사용한다.
          - 모든 정점이 연결될 때까지 이 과정을 반복한다.
        - 시간 복잡도: `O(e*logv)`
        - 사용 예시: 전기, 통신망 설계 등등.
      - 프림 알고리즘
        - 최소 신장 비용 트리를 찾는 알고리즘 중 하나. 하나의 정점에서 시작해 가장 낮은 가중치로 연결될 수 있는 정점을 찾아나간다.
        - 가중치가 음수여도 가능.
        - 동작 방식
          - 임의의 정점 하나를 고르는 것으로 시작한다.
          - 한 정점에 인접하지만 아직 포함되지 않은 정점을 최소의 비용을 가진 간선으로 연결.
          - 모든 정점이 연결될 때까지 반복한다.
        - 시간 복잡도: 최소의 비용을 가진 간선으로 연결할 정점을 찾는데 있어 우선순위 큐를 사용할 경우 `O(e*logv)`
  - 플로이드 워셜 알고리즘
    - 모든 정점 간 최소 비용을 구하는 알고리즘.
    - 음수 사이클을 만들 수 없다.
    - 동작 방식
      - 모든 정점 간의 비용을, 연결된 간선이 있을 경우 그 간선의 가중치로, 없을 경우 무한대로 초기화한다.
      - 모든 정점 `k`에 대해, `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])` 로 갱신
        - 즉, 한 정점에서 다른 정점으로 갈 때, 직접 바로 가는 것과 다른 정점을 거쳐서 가는 것 중 어느 것이 더 비용이 더 적게 드는지 계산한다.
      - 모든 정점끼리의 최소 비용 계산이 끝날 때까지 계속한다.
    - 시간 복잡도: `O(v**3)`
    - 사용 예시: 정점의 수가 많지 않을 때, 도시 간의 거리를 미리 계산할 때 등등.
  - 위상 정렬
    - 순환하지 않는 유향 그래프에서, 방향성을 거스르지 않도록 정점을 순서대로 정렬하는 방법.
      - 즉, 순서가 정해져있는 정점을 차례로 방문하기 위한 순서를 결정해주는 알고리즘이다.
      - 그래프의 흐름은 어떤 정점을 방문하기 전에 그 출신 정점들을 먼저 방문해야 한다는 조건으로 해석할 수 있다.
    - 사이클이 발생하지 않는 유향 그래프에서만 사용할 수 있다.
    - 동작 방식
      - 시작 정점(진입 차수가 0인 정점, 즉 해당 정점으로 들어가는 간선이 없는 정점)을 큐에 넣는다.
      - 큐에서 빼낸 정점과 연결된 모든 간선을 하나씩 제거한다. 즉, 간선마다 해당 정점으로부터 이어지는 다음 정점의 진입 차수를 1 낮춘다.
      - 간선 제거 이후 진입 차수가 0인 정점들을 큐에 넣는다.
      - 이 과정을 큐가 빌 때까지 반복한다.
        - 이 때, 모든 정점을 다 방문하지 않았는데 큐가 비어있다면 사이클이 발생한다는 의미이다.
    - 시간 복잡도: `O(v+e)`
    - 사용 예시: 대학교 선수과목 이수체계, 의존하는 모듈이 있는 소프트웨어 빌드 시스템, 작업 스케줄링 및 프로젝트 관리 등등.
- 이분 탐색
  - 오름차순 또는 내림차순으로 정렬된 배열에서, 답을 찾을 때까지 전체 범위에서부터 시작하여 가운데에 위치한 값을 기준으로 범위를 절반씩 좁혀나가는 탐색 방법.
  - 동작 원리 개요
    - 현재 단계의 범위에서 가장 왼쪽의 원소를 left번째 원소, 가장 오른쪽에 있는 원소를 right번째 원소라고 할 때, 찾고자 하는 값이 가운데에 위치한 값보다...
      - 작으면, 다음 단계의 범위의 right가 현재 단계의 가운데 바로 왼쪽으로 오게 되고,
      - 크면, 다음 단계의 범위의 left가 현재 단계의 가운데 바로 오른쪽으로 오게 된다.
    - 시간 복잡도: `O(logn)`
  - 탐색 방법
    - 일반적인 이분 탐색 방법
      - `left`를 시작점 인덱스, `right`를 `배열의 길이 - 1`(즉, 종점 인덱스)로 설정
      - `left > right`가 될 때까지...
        - `mid = (left + right) / 2`
        - `mid`에 해당하는 배열값이...
          - 찾고자 하는 배열값과 정확히 같다면, `mid`를 반환.
          - 찾고자 하는 배열값보다 작거나 같다면, `left = mid + 1`로 설정.
          - 찾고자 하는 배열값보다 크면, `right = mid - 1`로 설정.
    - Lower Bound 구하는 방법
      - `left`를 시작점 인덱스, `right`를 `배열의 길이`(즉, 종점 인덱스 + 1)로 설정
      - `left >= right`가 될 때까지...
        - `mid = (left + right) / 2`
        - `mid`에 해당하는 배열값이...
          - 찾고자 하는 배열값보다 작다면, `left = mid + 1`로 설정.
          - 찾고자 하는 배열값보다 크거나 같다면, `right = mid`로 설정.
      - 최종적으로 `right`에 해당하는 인덱스 값이 찾고자 하는 값에 대한 `Lower Bound`가 된다.
    - Uppper Bound 구하는 방법
      - `left`를 시작점 인덱스, `right`를 `배열의 길이`(즉, 종점 인덱스 + 1)로 설정
      - `left >= right`가 될 때까지...
        - `mid = (left + right) / 2`
        - `mid`에 해당하는 배열값이...
          - 찾고자 하는 배열값보다 작거나 같다면, `left = mid + 1`로 설정.
          - 찾고자 하는 배열값보다 크면, `right = mid`로 설정.
      - 최종적으로 `right`에 해당하는 인덱스 값이 찾고자 하는 값에 대한 `Upper Bound`가 된다.

## 분할 정복
- 하나의 거대한 문제를 작은 문제들로 분리하여 그 작은 문제들부터 시작하여 최종적으로 하나의 거대한 문제까지 해결해나가는 방법.

## 동적 계획법 (다이나믹 프로그래밍)
- 하나의 거대한 문제를 작은 문제들로 분리하여 그 작은 문제들부터 시작하여 최종적으로 하나의 거대한 문제까지 해결해나간다는 점에서 분할 정복과 비슷하다.
- 동적 계획법은 나눈 문제를 한 번만 해결하고 이전에 해결했던 문제의 결과값이 필요할 때 재계산하지 않고 바로 다시 불러올 수 있게끔 메모이제이션을 활용한다.
- 가장 대표적인 예시로, 재귀 함수가 아닌 메모 배열을 이용하여 피보나치 수열 구하기 문제가 있다.

## 백트래킹
- 모든 경우의 수를 찾되, 현재의 풀이에서 더 이상 유효하지 않다(해가 없다)고 판단될 때 이전 풀이로 되돌아가는 방식의 문제 해결 방법이다.
- 가지치기 (pruning): 백트래킹에서 더 이상 유효하지 않아 탐색하는 의미가 없는 부분을 제외하는 행위.

## 두 포인터
- 1차원 배열 내의 위치를 담은 변수 두 개를 이용하여 배열을 탐색하는 문제 해결 방법.
- 작동 방식
  - left, right 등의 두 개의 포인터를 둔다.
  - 조건에 따라 하나의 포인터 또는 두 포인터 모두 이동시킨다. 각 포인터는 한 방향으로만 이동한다.
- 시간 복잡도: `O(n)`
- 사용 예시: 배열 내 연속된 수의 합 중 가장 큰 수를 구하는 등, 연속된 부분 구간을 다룰 때 자주 사용된다.

## 유니온 파인드
- 여러 원소가 서로 같은 집합에 속해있는지 판별하는 알고리즘.
- 작동 방식
  - 초기에는 모든 노드가 자기 자신을 부모로 가지도록 초기화시킨다.
  - find(x): x의 부모를 찾는 연산이다.
    - 이 연산은 파라미터로 넘겨진 x의 부모가 본인일 때까지 재귀한다.
    - 그 이전까지, x의 부모는 자기의 부모의 부모, 즉 find(x의 부모)의 리턴값으로 대입된다.
  - union(x, y): x가 속한 집합과 y가 속한 집합을 병합시키는 연산이다.
    - x의 부모와 y의 부모를 각각 find(x)와 find(y)로 찾는다.
    - 찾은 각 두 부모의 인덱스 중, 먼저 앞서있는 쪽이 뒤에 있는 쪽의 부모로 한다.
      - 예를 들어, x의 부모의 인덱스가 y의 부모의 인덱스보다 앞서있으면 y의 부모의 부모 = x의 부모이다.
- 사용 예시: 그래프가 사이클을 이루는지 판별하는 문제에 사용된다. 사이클을 만들지 말아야 하는 크루스칼 알고리즘 역시, 이 알고리즘을 필요로 한다.
