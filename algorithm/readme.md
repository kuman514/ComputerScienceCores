# 알고리즘 모음집

## 정렬
- 버블 정렬
  - n번째서부터 시작하여 1번째 원소에 다다르기까지 서로 인접한 원소를 비교하는 정렬 방법.
  - 1~n번째 범위에서 시작하여, 1~(n-1)번째, 1~(n-2)번째, ..., 1~2번째 범위가 될 때까지 과정을 반복한다.
  - `O(n**2)`의 시간복잡도를 가진다.
- 선택 정렬
  - 정해진 위치에 들어갈 원소를 찾아 꽂는 정렬 방법.
  - 1번째 원소의 자리에는 가장 작은 원소를, 2번째 원소의 자리에는 2번째로 작은 원소를, ..., 마지막 원소의 자리에는 가장 큰 원소를 선택하여 꽂는다.
  - `O(n**2)`의 시간복잡도를 가진다.
- 삽입 정렬
  - 선택된 원소가 정렬된 부분의 몇 번째로 들어갈지 찾아 꽂는 정렬 방법.
  - n번째 원소가 선택되었을 때, 정렬된 부분의 원소들과 비교하여 몇 번째로 작은지 탐색하여 그 위치로 들어간다.
  - `O(n**2)`의 시간복잡도를 가진다.
- 병합 정렬
  - 하나의 리스트를 두 개의 균등한 크기의 부분 리스트로 분할하여, 분할된 부분 리스트부터 정렬하는 것으로 시작하여, 두 개의 정렬된 부분 리스트를 합하여 최종적으로 정렬된 전체 리스트로 병합시키는 정렬 방법.
  - `O(n*logn)`의 시간복잡도를 가진다.
  - 분할된 부분 리스트에 대한 추가적인 메모리가 요구된다.
- 힙 정렬
  - 힙 트리를 이용하여 가장 작은/큰 원소를 하나하나 빼내는 정렬 방법.
  - `O(n*logn)`의 시간복잡도를 가진다.
- 퀵 정렬
  - 리스트 안의 하나의 원소를 피벗으로 삼아, 피벗보다 작을 경우 왼쪽 부분 리스트로, 클 경우 오른쪽 부분 리스트로 원소를 이동시켜, 부분 리스트에서도 동일한 방법을 수행하는 정렬 방법.
  - `O(n*logn)`의 시간복잡도를 가지지만, 최악의 경우 `O(n**2)`의 시간복잡도를 가진다.

## 탐색
- 가중치가 없는 그래프 탐색
  - BFS(너비 우선 탐색)
    - 그래프의 시작 정점으로부터 인접한 모든 정점들을 우선 방문하는 탐색법이다.
    - 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 정점에 대해서도 너비 우선 탐색을 적용한다.
    - 큐를 활용하여 다음에 방문할 정점을 결정한다.
  - DFS(깊이 우선 탐색)
    - 그래프의 시작 정점으로부터 인접한 하나의 정점을 우선적으로 최대한 깊이 탐색하는 탐색법이다.
    - 하나의 경로를 최대한 가다가 길이 막히면 다른 갈림길을 탐색한다.
    - 스택 또는 재귀함수로 다음에 방문할 정점을 결정한다.
- 가중치가 있는 그래프 탐색
  - 데이크스트라
    - 가중치 그래프에서, 하나의 정점으로부터 나머지 모든 정점으로 가는 최소 비용을 계산하는 알고리즘.
    - 가중치가 음수가 아닌 경우에만 가능.
    - 동작 방식
      - 시작 정점으로의 비용은 0으로, 그 외 다른 정점으로의 비용은 무한대로 초기화.
      - 현재까지의 최소 비용이 가장 낮은 정점을 선택.
      - 그 선택된 정점에 대해 인접한 정점까지의 가중치를 합하여 최소 비용을 갱신.
      - 모든 정점으로의 비용에 대한 계산이 완료될 때까지 반복.
    - 시간 복잡도: 정점을 선택하는데 있어 우선순위 큐를 사용할 경우 `O(e*logv)`
    - 사용 예시: GPS, 네비게이션, 네트워크 라우팅 등등.
  - 최소 비용 신장 트리
    - 신장 트리란
      - 그래프의 모든 정점을 연결한 간선들의 집합. 즉, 모든 정점에 대한 최소한의 연결만을 남긴 그래프이다.
      - 트리이므로 사이클이 발생하지 않아야 한다.
      - 하나의 정점에서 다른 인접한 정점으로의 간선이 두 개 이상일 경우, 하나의 간선만 채택한다.
    - 최소 비용 신장 트리란
      - 신장 트리 중 비용이 가장 낮도록 구성된 트리.
    - 유형
      - 크루스칼 알고리즘
        - 최소 신장 비용 트리를 찾는 알고리즘 중 하나. 정점을 연결한 모든 간선을 가중치 기준으로 정렬하여 최소 신장 트리를 만들어낸다.
        - 가중치가 음수여도 가능.
        - 동작 방식
          - 모든 간선을 가중치 오름차순으로 정렬.
          - 가중치가 가장 낮은 간선부터 확인하여, 두 정점이 연결되어 있지 않다면 해당 간선을 선택한다.
            - 이 때, 사이클 생성을 방지하기 위해 유니온 파인드 알고리즘을 사용한다.
          - 모든 정점이 연결될 때까지 이 과정을 반복한다.
        - 시간 복잡도: `O(e*logv)`
        - 사용 예시: 전기, 통신망 설계 등등.
      - 프림 알고리즘
        - 최소 신장 비용 트리를 찾는 알고리즘 중 하나. 하나의 정점에서 시작해 가장 낮은 가중치로 연결될 수 있는 정점을 찾아나간다.
        - 가중치가 음수여도 가능.
        - 동작 방식
          - 임의의 정점 하나를 고르는 것으로 시작한다.
          - 한 정점에 인접하지만 아직 포함되지 않은 정점을 최소의 비용을 가진 간선으로 연결.
          - 모든 정점이 연결될 때까지 반복한다.
        - 시간 복잡도: 최소의 비용을 가진 간선으로 연결할 정점을 찾는데 있어 우선순위 큐를 사용할 경우 `O(e*logv)`
  - 플로이드 워셜 알고리즘
    - 모든 정점 간 최소 비용을 구하는 알고리즘.
    - 음수 사이클을 만들 수 없다.
    - 동작 방식
      - 모든 정점 간의 비용을, 연결된 간선이 있을 경우 그 간선의 가중치로, 없을 경우 무한대로 초기화한다.
      - 모든 정점 `k`에 대해, `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])` 로 갱신
        - 즉, 한 정점에서 다른 정점으로 갈 때, 직접 바로 가는 것과 다른 정점을 거쳐서 가는 것 중 어느 것이 더 비용이 더 적게 드는지 계산한다.
      - 모든 정점끼리의 최소 비용 계산이 끝날 때까지 계속한다.
    - 시간 복잡도: `O(v**3)`
    - 사용 예시: 정점의 수가 많지 않을 때, 도시 간의 거리를 미리 계산할 때 등등.
- 이분 탐색
  - 오름차순 또는 내림차순으로 정렬된 배열에서, 답을 찾을 때까지 전체 범위에서부터 시작하여 가운데에 위치한 값을 기준으로 범위를 절반씩 좁혀나가는 탐색 방법.
  - 현재 단계의 범위에서 가장 왼쪽의 원소를 left번째 원소, 가장 오른쪽에 있는 원소를 right번째 원소라고 할 때, 찾고자 하는 값이 가운데에 위치한 값보다...
    - 작으면, 다음 단계의 범위의 right가 현재 단계의 가운데 바로 왼쪽으로 오게 되고,
    - 크면, 다음 단계의 범위의 left가 현재 단계의 가운데 바로 오른쪽으로 오게 된다.

## 분할 정복
- 하나의 거대한 문제를 작은 문제들로 분리하여 그 작은 문제들부터 시작하여 최종적으로 하나의 거대한 문제까지 해결해나가는 방법.

## 동적 계획법 (다이나믹 프로그래밍)
- 하나의 거대한 문제를 작은 문제들로 분리하여 그 작은 문제들부터 시작하여 최종적으로 하나의 거대한 문제까지 해결해나간다는 점에서 분할 정복과 비슷하다.
- 동적 계획법은 나눈 문제를 한 번만 해결하고 이전에 해결했던 문제의 결과값이 필요할 때 재계산하지 않고 바로 다시 불러올 수 있게끔 메모이제이션을 활용한다.
- 가장 대표적인 예시로, 재귀 함수가 아닌 메모 배열을 이용하여 피보나치 수열 구하기 문제가 있다.

## 백트래킹
- 모든 경우의 수를 찾되, 현재의 풀이에서 더 이상 유효하지 않다(해가 없다)고 판단될 때 이전 풀이로 되돌아가는 방식의 문제 해결 방법이다.
- 가지치기 (pruning): 백트래킹에서 더 이상 유효하지 않아 탐색하는 의미가 없는 부분을 제외하는 행위.

## 두 포인터
- 1차원 배열 내의 위치를 담은 변수 두 개를 이용하여 배열을 탐색하는 문제 해결 방법.
- 작동 방식
  - left, right 등의 두 개의 포인터를 둔다.
  - 조건에 따라 하나의 포인터 또는 두 포인터 모두 이동시킨다. 각 포인터는 한 방향으로만 이동한다.
- 시간 복잡도: `O(n)`
- 사용 예시: 배열 내 연속된 수의 합 중 가장 큰 수를 구하는 등, 연속된 부분 구간을 다룰 때 자주 사용된다.

## 유니온 파인드
- 여러 원소가 서로 같은 집합에 속해있는지 판별하는 알고리즘.
- 작동 방식
  - 초기에는 모든 노드가 자기 자신을 부모로 가지도록 초기화시킨다.
  - find(x): x의 부모를 찾는 연산이다.
    - 이 연산은 파라미터로 넘겨진 x의 부모가 본인일 때까지 재귀한다.
    - 그 이전까지, x의 부모는 자기의 부모의 부모, 즉 find(x의 부모)의 리턴값으로 대입된다.
  - union(x, y): x가 속한 집합과 y가 속한 집합을 병합시키는 연산이다.
    - x의 부모와 y의 부모를 각각 find(x)와 find(y)로 찾는다.
    - 찾은 각 두 부모의 인덱스 중, 먼저 앞서있는 쪽이 뒤에 있는 쪽의 부모로 한다.
      - 예를 들어, x의 부모의 인덱스가 y의 부모의 인덱스보다 앞서있으면 y의 부모의 부모 = x의 부모이다.
- 사용 예시: 그래프가 사이클을 이루는지 판별하는 문제에 사용된다. 사이클을 만들지 말아야 하는 크루스칼 알고리즘 역시, 이 알고리즘을 필요로 한다.
