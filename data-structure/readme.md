# 자료구조 모음집

## 자료구조의 종류

### 배열
- 같은 타입의 자료가 연속적으로 이루어져 있는 자료 구조.
- 연속적인 자료 구조이다.
- 연산별 시간복잡도
  - 인덱스 접근: `O(1)`
    - 배열은 연속된 자료구조이기 때문에, 인덱스 번호만 알면 바로 중간 접근할 수 있다.
  - 탐색: `O(n)`
    - 특정한 값을 찾고자 할 때, 배열의 모든 원소를 하나하나씩 찾아야 하기 때문이다.
  - 삽입/삭제: `O(n)`
    - 원소의 삽입/삭제가 발생했을 경우, 그 뒤 모든 원소들의 인덱스를 하나씩 뒤로 밀거나 앞으로 당겨야 하기 때문이다.

### 링크드 리스트
- 노드 단위로 이루어진 자료 구조.
- 노드는 실제 자료와 그 다음 노드를 가리키는 참조값으로 구성되어 있는 자료의 단위이다.
- 그 다음 노드를 가리키는 참조값이 없는 (즉 다음으로 가리키는 노드가 없는) 노드가 가장 마지막 노드이다.
- 불연속적인 자료 구조이다.
- 연산별 시간복잡도
  - 탐색: `O(n)`
    - 특정 노드를 찾아가려면 맨 앞 노드(`head`)부터 시작해 순차적으로 찾아보아야 하기 때문이다.
  - 삽입/삭제: `O(1)`
    - 노드의 위치만 알고 있다면, 이전 노드의 다음 참조(`next`)만 변경해주면 되기 때문이다.

### 스택
- First In Last Out.
- 맨 처음 넣은 자료일수록 맨 나중에 꺼낼 수 있는 형태의 선형 자료 구조.
- 연산별 시간복잡도
  - 탐색: `O(n)`
    - 특정 위치에 있는 원소를 확인하려면 스택 내 모든 자료를 들어내보아야 하기 때문이다.
  - 삽입/삭제: `O(1)`
    - 스택은 맨 위쪽(`top`)에서만 삽입(`push`) 및 삭제(`pop`)가 이루어진다.

### 큐
- First In First Out.
- 맨 처음 넣은 자료일수록 맨 먼저 꺼낼 수 있는 형태의 선형 자료 구조.
- 연산별 시간복잡도
  - 탐색: `O(n)`
    - 특정 위치에 있는 원소를 확인하려면 큐 내 모든 자료를 들어내보아야 하기 때문이다.
  - 삽입/삭제: `O(1)`
    - 큐는 맨 뒤쪽(`back`)에서만 삽입(`push`)이, 맨 앞쪽(`front`)에서만 삭제(`pop`)가 이루어진다.

### 덱
- 맨 앞과 맨 뒤 양 끝에서 자료의 삽입과 삭제가 가능한 선형 자료 구조.
- 연산별 시간복잡도
  - 탐색: `O(n)`
    - 특정 위치에 있는 원소를 확인하려면 덱 내 모든 자료를 들어내보아야 하기 때문이다.
  - 삽입/삭제: `O(1)`
    - 덱은 맨 앞쪽(`front`)과 맨 뒤쪽(`back`)에서만 삽입(`push`) 및 삭제(`pop`)가 이루어진다.

### 해시
- 해시 함수값에 따라 인덱싱되는 자료 구조.
- 해시 용어
  - 키: 해시 함수의 입력값
  - 해시 함수: 키의 값을 고정된 길이의 해시값으로 변환시켜주는 함수
  - 해시 테이블: 해시값을 주소삼아 데이터와 함께 키-값 쌍으로 저장한 테이블
  - 버킷(또는 슬롯): 해시 테이블에서 데이터가 저장되는 곳
- 좋은 해시 함수의 조건
  - 키를 고르게 분포시킨다.
  - 해시 충돌 발생 빈도가 낮다.
  - 연산이 빠르다.
  - 단방향성이다. (즉, 해싱한 값으로 원본 값을 유추하지 못한다)
- 시간복잡도
  - 평균: `O(1)`
    - 해시 함수값을 기반으로 인덱스 접근을 하므로, 데이터의 양과 상관없이 즉시 접근이 가능하다.
  - 최악: `O(n)`
    - 여러 키값이 우연히 모두 해시 함수값에서 충돌하여 한 쪽 버킷에만 몰려있게 될 경우, 특정한 값을 찾기 위해 해당 버킷을 순차적으로 탐색해야 한다.
- 해시 충돌
  - 서로 다른 키값이 해시 함수값이 서로 같은 현상.
    - 즉, 해시 함수가 두 개 이상의 키를 같은 버킷으로 보내는 현상이다.
  - 해결 방법
    - 체이닝
      - 기존 버킷 내에 있던 데이터에 신규 데이터를 링크드 리스트 형태로 연결하여 추가하는 방법.
      - 장점: 해시 충돌에 대비해 미리 공간을 확보해놓을 필요가 없다.
      - 단점: 동일한 해시에 데이터가 많이 연결되면 검색의 성능이 낮아진다.
    - 개방 주소법
      - 비어있는 버킷의 주소를 찾는 방법
      - 개방 주소법의 종류
        - 선형 탐색
          - 해시 함수값에서 고정 폭으로 건너뛰면서 비어있는 버킷에 데이터를 저장하는 탐색법.
          - 특정 해시 함수값 주변 버킷이 모두 채워져있는 현상에 취약하다. (Primary Clustering)
        - 제곱 탐색
          - 해시 함수값에서 n**2칸(예: 1칸, 4칸, 9칸, 16칸, ...)씩 건너뛰면서 비어있는 버킷에 데이터를 저장하는 탐색법.
          - 해시 함수값이 같은 경우가 많이 발생하면 공간을 많이 확보해야 함.
          - 새 해시값이 항상 같은 경로를 따라 비어있는 버킷을 찾아다니는 현상에 취약하다. (Secondary Clustering)
        - 이중 해싱
          - 해시 함수를 두 개 이용하고, 그 중 하나에 해시 충돌이 발생할 때마다 1씩 증가하는 `i`를 곱하는 방법.
          - `dh(k, i) = (h1(k) + h2(k) * i) % m`
            - `h1(k)`: 첫번째 해시함수.
            - `h2(k)`: 두번째 해시함수.
              - 이 때, `h2(k) < m`이어야 함.
              - 즉 `h2(k)`는 `m`과 서로소여야 함.
            - `i`: 해시 충돌 횟수.
            - `m`: 해시 테이블의 크기. 소수여야 함.
          - 장점
            - Primary Clustering과 Secondary Clustering을 해결한다.
            - 해시 함수값이 거의 고르게 분포되어 있다.
            - 빈 버킷 탐색(Probing) 중 가장 빠르다.
          - 단점
            - 좋은 해시 함수를 사용해야 할 것이다.
            - 메모리를 많이 잡아먹는다.
            - 연산의 비용이 크다.
            - 참조 지역성을 잘 지키는 편은 아니라, 캐시 성능이 좋지 않다.
            - 작은 테이블에는 부적합하다.

### 집합
- 중복을 허용하지 않고, 자료에 순서가 없는 자료 구조.

### 맵
- 키와 값이 한 쌍을 이루어 저장되는 자료 구조.
- 키는 중복될 수 없다.

### 그래프
- 정점과 이들을 잇는 간선으로 이루어진 비선형 자료 구조.
- 그래프 용어
  - 사이클: 어떤 정점에서 그 정점으로 되돌아오는 경로
- 그래프의 종류
  - 무향 그래프: 간선에 방향이 없는 그래프.
  - 유향 그래프: 간선에 방향이 있는 그래프.
  - 다중 그래프: 두 정점 사이에 다수의 간선이 있는 그래프.
  - 가중치 그래프: 간선에 가중치가 있는 그래프.

### 트리
- 사이클을 이루지 않는 그래프.
- 트리 용어
  - 루트 노드: 부모 노드가 없는 노드.
  - 부모 노드: 루트 노드를 향한 간선으로 직접 서로 연결된 노드.
  - 자식 노드: 루트 노드의 반대 방향을 향한 간선으로 직접 서로 연결된 노드.
  - 리프 노드: 자식 노드가 없는 노드.
  - 형제 노드: 부모 노드가 서로 동일한 노드.
  - 차수: 자식 노드의 개수.
  - 레벨: 어떤 노드로부터 루트에 다다르기까지의 간선 개수.
  - 길이: 어떤 노드로부터 또다른 노드에 다다르기까지의 간선 개수.
  - 트리의 높이: 루트로부터 가장 깊은 리프 노드까지의 간선 개수.
  - 트리의 차수: 트리 내 노드의 차수의 최대값.
  - 크기: 트리 내 노드의 개수.
  - 서브트리: 트리의 일부분으로써 완전히 포함되는 트리.
- 트리 순회 방법
  - 전위 순회(Preorder Traversal)
    - 부모 노드를 가장 먼저 방문하는 순회 방법
    - 부모 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드
  - 중위 순회(Inorder Traversal)
    - 부모 노드를 중간 순서로 방문하는 순회 방법
    - 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드
  - 후위 순회(Postorder Traversal)
    - 부모 노드를 가장 나중에 방문하는 순회 방법
    - 왼쪽 자식 노드 -> 오른쪽 자식 노드 -> 부모 노드
- 트리의 종류
  - 이진 트리: 차수가 최대 2인 트리, 즉 자식 노드를 최대 2개까지만 가지는 트리.
    - 완전 이진 트리: 모든 리프 노드의 높이의 차이가 최대 1이며, 각 노드마다 오른쪽 자식이 있다면 반드시 왼쪽 자식도 있는 형태의 트리이다. 즉, 왼쪽부터 오른쪽까지 차곡차곡 채워나간 형태의 이진 트리.
    - 힙 트리: 완전 이진 트리 중 모든 부모 노드가 자식보다 큰 (또는 작은) 가치를 가지는 트리. 루트 노드가 가장 큰 (또는 작은) 값을 가지고 있다.
    - 포화 이진 트리: 완전 이진 트리 중 모든 리프 노드의 높이가 동일한 트리. 즉, 리프 노드가 아니라면 자식이 반드시 2개 있는 형태의 트리.
    - 이진 탐색 트리
      - 모든 노드가 자기 자신보다 작으면 왼쪽 자식으로, 크면 오른쪽 자식으로 두는 이진 트리.
      - 검색 시 시간 복잡도: 평균적으로는 `O(logn)`, 트리가 편향되는(Skewed) 등등 최악의 경우 `O(n)`
      - 편향되는 문제점을 개선한 균형 이진 탐색 트리
        - 트리의 높이가 항상 `O(logn)` 수준으로 유지하는 이진 검색 트리
        - 삽입/삭제 시 스스로 구조를 재조정(Rebalancing)한다.
        - 균형 이진 탐색 트리의 종류
          - AVL 트리 (Adelson-Velsky and Landis Tree)
            - 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이를 최대 1로 엄격하게 맞추는 균형 이진 탐색 트리.
            - 리프 노드들끼리의 높이 차이가 1을 초과하면 회전을 통해 균형을 유지한다.
            - 장점: 리프 노드들끼리의 높이 차이가 1 이하임을 유지하므로 검색이 매우 빠르다.
            - 단점: 리프 노드들끼리의 높이의 균형을 엄격하게 맞추므로, 재배치 작업이 자주 발생하는 편이다.
            - 용도: 데이터 검색이 삽입/삭제보다 빈번할 때 쓰인다.
          - 레드-블랙 트리
            - 효율적인 균형 이진 탐색 트리. 각 노드에 Red나 Black을 부여하고, 아래 규칙을 통해 균형을 유지한다.
            - 규칙
              - 모든 노드는 Red 또는 Black이다.
              - 루트 노드는 반드시 Black이다.
              - 모든 리프 노드는 반드시 Black이다.
              - Red 노드의 자식은 반드시 Black이다. 즉, 연속으로 Red인 노드들은 존재하지 않는다.
              - 임의의 노드로부터 리프 노드까지 가는 경로에 있는 Black 노드의 개수는 모두 동일하다.
            - 장점: AVL 트리보다 덜 엄격하여 회전이 덜 자주 일어나기 때문에, 삽입/삭제/탐색 등의 전반적인 성능이 균형을 이룬다.
            - 용도: 범용적인 집합이나 맵 등의 자료구조에 쓰인다. (Java의 `TreeMap`과 C++의 `std::map` 등등)
  - [B-Tree와 B+Tree는 데이터베이스 문서의 인덱스 구현 예시 부분을 참조](https://github.com/kuman514/ComputerScienceCores/blob/main/database/readme.md#%EC%9D%B8%EB%8D%B1%EC%8A%A4)